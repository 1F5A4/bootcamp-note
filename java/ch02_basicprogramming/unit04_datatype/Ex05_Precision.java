package ch02_basicprogramming.unit04_datatype;

/*
    - 정밀도
        - float(4byte), double(8byte) -> 부동소수점 방식
        - 일부 소수는 정확히 표현 불가 -> 근사값 저장으로 오차 발생
*/

public class Ex05_Precision {
    public static void main(String[] args) {
        int i1 = 2_000_000_000;
        int i2 = 2_000_000_050;

        float f1 = 2_000_000_000;
        float f2 = 2_000_000_050;

        double d1 = 2_000_000_000;
        double d2 = 2_000_000_050;

        System.out.printf("int: %d %d\n", i1, i2);
        System.out.printf("float: %.2f %.2f\n", f1, f2);
        System.out.printf("double: %.2f %.2f\n", d1, d2);
    }
}


/* CONCEPT -------------------------------------------------------------------------------------------------------------

    1. 정밀도 (Precision)
        - 정수형은 표현 가능한 값의 '범위'가 중요
        - 실수형은 '소수점 이하의 자릿수'까지 얼마나 정확히 표현할 수 있는지가 중요
    
    2. float vs double
        - float: 4 byte (약 7자리 정밀도)
        - double: 8 byte (약 15~16자리 정밀도)
        - float은 double보다 표현할 수 있는 정수나 소수의 '정밀도'가 낮음
    
    3. 정밀도 손실 (Precision Loss)
        - 큰 수를 float에 저장하면 정밀도가 부족해 오차가 생김
        - 예: 2_000_000_000과 2_000_000_050 → float에서는 둘 다 같은 값으로 출력될 수 있음
        - double은 '충분한 정밀도'를 가지므로 정확한 값을 유지
        
    4. 부동소수점(Floating-Point)
        - 실수형(float, double)은 부동소수점 방식으로 저장됨
        - 고정된 소수점이 아니라, 지수와 가수(예: 1.2 × 10^3) 형태로 저장
        - 아주 크거나 작은 수를 표현할 수 있지만, 정확도에 한계가 있음
        - `%.2f`는 부동소수점 실수를 소수 둘째 자리까지 '반올림'해서 출력하는 포맷
        
        Q. 대체 왜 정확도에 한계가 있는 것인가?
            - 일부 10진수 소수는 2진수로 정확히 표현할 수 없음
                - 0.1 -> 0.0001100110011...(2) (무한 반복)
                    - 컴퓨터는 '근사값'으로 저장할 수밖에 없음
            - 컴퓨터는 실수를 2진수의 음의 거듭제곱(2^{-1}, 2{-2}, ...) 조합으로 표현
                - 1/10 = 0.1은 이 조합으로 정확히 나타낼 수 없음
                    - 무한소수가 되고, 잘라서 저장되기 때문에 오차 발생
                   
            ## 10진수 0.1을 2진수로 표현하는 법!
                - 2진 소수를 자리 단위로 '추출'하면, 각 곱에서 '정수 부분 = 현재 자릿수'의 값
                    - 즉, 10진수 0.1의 2진수는 '곱하기 2를 반복하며 정수 부분만' 따서 표현
                        0.1 x 2 = 0.2   -> 0
                        0.2 x 2 = 0.4   -> 0
                        0.4 x 2 = 0.8   -> 0
                        0.8 x 2 = 1.6   -> 1
                        0.6 x 2 = 1.2   -> 1
                        0.2 x 2 = 0.4   -> 0
                        0.4 x 2 = 0.8   -> 0
                        0.8 x 2 = 1.6   -> 1
                        ...
                        -> 0.0001100110011001100...(2) (무한 소수)
                        
            - 실수 자료형의 한계
                - float (4byte), double (8byte)
                - 정밀도와 표현 범위가 다름
                - 자릿수가 넘어가면 '뒷자리 잘림' 또는 '근사 오차' 발생

            - 정확한 계산이 필요한 경우?
                - 통화, 금융 등 정밀 계산이 필요한 경우
                - float, double 대신 BigDecimal 클래스 사용

    5. 출력 서식
        - %.2f: 소수점 둘째 자리까지 실수를 출력함
        - %d: 정수를 10진수 형태로 출력

--------------------------------------------------------------------------------------------------------------------- */
